#include <vector>
#include <fstream>

std::ostream& operator<< (std::ostream& push, const std::vector<int>& list) 
{
	push << list.size() << "\t|";
	for (auto& i : list)
	{
		push << " " << &i;
	}
	return push;
}

int main() 
{
	std::ofstream file("data.txt");
	std::vector<int> list;
	for (int i = 0; i < 64; ++i) 
	{
		list.push_back(0);
		file << list << "\n";
	}
	file << "\n Pop_back \n \n";

	while (!list.empty())
	{
		list.pop_back();
		file << list << "\n";
	}
}

/* 
	Ответы:
		1. Сравнив адреса элементов вектора с одинаковыми индексами,
	я пришел к выводу, что число повторяющихся подряд одинаковых 
	первых элементов растет, и со временем все следующие адреса 
	повторяют предыдущий с добавлением дополнительного элемента(sizeof(int)).
	Дело в том, что изначально программа уделяет минимальное возможное
	количество памяти, для сохранения производительности и вместимости, 
	однако, когда мы увеличиваем вектор, то и количество выделяемой памяти 
	тоже увеличивается.
		2. Нет, так как весь массив был перемещён в новую память. 
	Однако если этой памяти будет недостаточно для вектора 25 элементов 
	данный массив там не разместится.
		3. В data.txt можно увидеть, чот после изначального цикла 
	происходит цикл удаления элементов с конца по одному, пока весь массив 
	не станет пустым, каждый шаг можно увидеть в соответствующей строке. 
	
		4. Когда оператор принимает вектор по значению, то количество 
	выделенной памяти не уменьшается, поэтому при уменьшении вектора 
	адреса оставшихся элементов не меняются. Но при увеличивании вектора, 
	все остается таким же.
*/